// Translation object (same as before)
const translations = {
    en: {
        companyTagline: "Professional Device Repair Services",
        invoice: "INVOICE",
        billTo: "Bill To",
        deviceInfo: "Device Information",
        type: "Type",
        brand: "Brand",
        model: "Model",
        serial: "Serial",
        repairIssue: "Issue",
        trackProgress: "Track Repair Progress",
        serviceTicketId: "Service Ticket ID",
        trackProgressBtn: "Track Progress",
        loading: "Loading...",
        noData: "No repair data available",
        invoiceDate: "Invoice Date",
        dueDate: "Due Date",
        repairDetails: "Repair Details",
        description: "Description",
        qty: "Qty",
        unitPrice: "Unit Price",
        total: "Total",
        parts: "parts",
        labor: "labor",
        subtotal: "Subtotal",
        discount: "Discount",
        tax: "Tax",
        totalAmountDue: "Total Amount Due",
        payViaBankTransfer: "Pay via Transfer",
        paymentInstructions: "Payment Instructions",
        paymentDetails: "Payment Details",
        step1: "Use the above payment information to make the transfer.",
        step2: "Enter the exact amount",
        step3: "Use this as the transfer reference",
        step4: "After transferring, confirm your payment in the section below.",
        bank: "Bank",
        account: "Account",
        accountName: "Account Name",
        confirmPayment: "Confirm Payment",
        amountTransferred: "Amount Transferred",
        transferDateTime: "Transfer Date & Time",
        transactionRef: "Transaction Reference (Optional)",
        uploadReceipt: "Upload Receipt/Confirmation",
        uploadFile: "Upload a file",
        dragDrop: "or drag and drop",
        fileTypes: "PNG, JPG, PDF up to 10MB",
        additionalNotes: "Additional Notes (Optional)",
        notesPlaceholder: "Any additional information about the payment...",
        confirmPaymentBtn: "Confirm Payment Completed",
        confirmingPayment: "Confirming...",
        paymentReceived: "Payment Confirmation Received!",
        paymentReceivedDesc: "Thank you for confirming your payment. We will verify the transfer and send you a receipt within 24 hours.",
        statusPending: "Status: Pending Verification",
        contactSupport: "Contact & Support",
        phone: "Phone",
        email: "Email",
        address: "Address",
        thankYou: "Thank You for Choosing {companyName}!",
        thankYouDesc: "We appreciate your business and trust in our repair services. Your device has been carefully repaired and tested to ensure optimal performance.",
        nextSteps: "Next Steps",
        noInvoiceInfo: "No invoice information available",
        qrCode: "Scan QR Code"
        
    },
    vi: {
        
        companyTagline: "Dịch Vụ Sửa Chữa Thiết Bị Chuyên Nghiệp",
        invoice: "HÓA ĐƠN",
        billTo: "Thông Tin Khách Hàng",
        deviceInfo: "Thông Tin Thiết Bị",
        type: "Loại",
        brand: "Thương Hiệu",
        model: "Mẫu",
        serial: "Số Serial",
        repairIssue: "Vấn đề",
        trackProgress: "Theo Dõi Tiến Độ Sửa Chữa",
        serviceTicketId: "Mã Phiếu Dịch Vụ",
        qrCode: "Quét Mã QR",

        trackProgressBtn: "Theo Dõi Tiến Độ",
        loading: "Đang tải...",
        noData: "Không có dữ liệu sửa chữa",
        invoiceDate: "Ngày Hóa Đơn",
        dueDate: "Ngày Đến Hạn",
        repairDetails: "Chi Tiết Sửa Chữa",
        description: "Mô Tả",
        qty: "SL",
        unitPrice: "Đơn Giá",
        total: "Tổng",
        parts: "linh kiện",
        labor: "nhân công",
        subtotal: "Tạm Tính",
        discount: "Giảm Giá",
        tax: "Thuế",
        totalAmountDue: "Tổng Số Tiền Phải Trả",
        payViaBankTransfer: "Thanh Toán Qua Chuyển Khoản",
        paymentInstructions: "Hướng Dẫn Thanh Toán",
        paymentDetails: "Chi Tiết Thanh Toán",
        step1: "Sử dụng thông tin thanh toán trên để chuyển khoản.",
        step2: "Nhập chính xác số tiền",
        step3: "Sử dụng nội dung này làm tham chiếu chuyển khoản",
        step4: "Sau khi chuyển khoản, hãy xác nhận thanh toán của bạn ở phần bên dưới.",
        bank: "Bank",
        account: "Account",
        accountName: "Account Name",
        confirmPayment: "Xác Nhận Thanh Toán",
        amountTransferred: "Số Tiền Đã Chuyển",
        transferDateTime: "Ngày & Giờ Chuyển Khoản",
        transactionRef: "Mã Giao Dịch (Tùy Chọn)",
        uploadReceipt: "Tải Lên Biên Lai/Xác Nhận",
        uploadFile: "Tải lên tệp",
        dragDrop: "hoặc kéo và thả",
        fileTypes: "PNG, JPG, PDF tối đa 10MB",
        additionalNotes: "Ghi Chú Bổ Sung (Tùy Chọn)",
        notesPlaceholder: "Bất kỳ thông tin bổ sung nào về thanh toán...",
        confirmPaymentBtn: "Xác Nhận Đã Hoàn Tất Thanh Toán",
        confirmingPayment: "Đang xác nhận...",
        paymentReceived: "Đã Nhận Xác Nhận Thanh Toán!",
        paymentReceivedDesc: "Cảm ơn bạn đã xác nhận thanh toán. Chúng tôi sẽ xác minh chuyển khoản và gửi cho bạn biên lai trong vòng 24 giờ.",
        statusPending: "Trạng Thái: Đang Chờ Xác Minh",
        contactSupport: "Liên Hệ & Hỗ Trợ",
        phone: "Điện Thoại",
        email: "Email",
        address: "Địa Chỉ",
        thankYou: "Cảm Ơn Bạn Đã Chọn {companyName}!",
        thankYouDesc: "Chúng tôi đánh giá cao việc kinh doanh và sự tin tưởng của bạn vào dịch vụ sửa chữa của chúng tôi. Thiết bị của bạn đã được sửa chữa và kiểm tra cẩn thận để đảm bảo hiệu suất tối ưu.",
        nextSteps: "Các Bước Tiếp Theo",
        noInvoiceInfo: "Chưa có thông tin hóa đơn",
        
    }
};


// Mobile-specific initialization
function initializeMobileFeatures() {
    const trackProgressLink = document.getElementById('track-progress-link');
    if (trackProgressLink) {
        trackProgressLink.addEventListener('click', function(e) {
            e.preventDefault(); // Prevent default link behavior
            const ticketId = repairData ? repairData.ticketId : 'ST-2024-0156';
            const trackingUrl = `https://realtimecs.rtworkspace.com/webapp/default/dmView?id=service-ticket&token=realtimecs&ticket_id=${ticketId}&lang=${currentLanguage}`;
            window.open(trackingUrl, '_blank');
        });
    }

    // Touch feedback for interactive elements
    const touchElements = document.querySelectorAll('.touch-feedback');
    touchElements.forEach(element => {
        element.addEventListener('touchstart', function() {
            this.style.transform = 'scale(0.98)';
        });
        
        element.addEventListener('touchend', function() {
            this.style.transform = 'scale(1)';
        });
    });

    // Prevent zoom on input focus for iOS
    const inputs = document.querySelectorAll('input, textarea, select');
    inputs.forEach(input => {
        input.addEventListener('focus', function() {
            if (window.innerWidth < 768) {
                document.querySelector('meta[name=viewport]').setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0');
            }
        });
        
        input.addEventListener('blur', function() {
            if (window.innerWidth < 768) {
                document.querySelector('meta[name=viewport]').setAttribute('content', 'width=device-width, initial-scale=1.0');
            }
        });
    });
}

// Language switching functionality
function initializeLanguageSwitcher() {
    const languageToggle = document.getElementById('language-toggle');
    const languageDropdown = document.getElementById('language-dropdown');
    const languageOptions = document.querySelectorAll('.custom-select-option');

    languageToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        languageDropdown.classList.toggle('show');
    });

    document.addEventListener('click', () => {
        languageDropdown.classList.remove('show');
    });

    languageOptions.forEach(option => {
        option.addEventListener('click', (e) => {
            e.stopPropagation();
            const selectedLang = option.dataset.lang;
            switchLanguage(selectedLang);
            languageDropdown.classList.remove('show');
        });
    });

    switchLanguage(currentLanguage);
}

function switchLanguage(lang) {
    currentLanguage = lang;
    localStorage.setItem('preferredLanguage', lang);

    // Update language toggle display
    const currentFlag = document.getElementById('current-flag');
    const currentLang = document.getElementById('current-lang');

    if (lang === 'vi') {
        currentFlag.textContent = '🇻🇳';
        currentLang.textContent = 'Tiếng Việt';
    } else {
        currentFlag.textContent = '🇺🇸';
        currentLang.textContent = 'English';
    }

    // Update active language option
    document.querySelectorAll('.custom-select-option').forEach(option => {
        option.classList.toggle('active', option.dataset.lang === lang);
    });

    // Update HTML lang attribute
    document.documentElement.lang = lang;

    // Re-evaluate companyDisplayName based on new language
    if (repairData) {
        updateCompanyDisplayName();
    }

    // Translate all elements
    translatePage();
    populateRepairItems(); // Refresh repair items with new language
    populateInvoiceData(); // Re-populate invoice data to apply masking/translations
}

function translatePage() {
    const elements = document.querySelectorAll('[data-translate]');
    elements.forEach(element => {
        const key = element.dataset.translate;
        if (translations[currentLanguage] && translations[currentLanguage][key]) {
            element.textContent = translations[currentLanguage][key];
        }
    });

    // Handle placeholder translations
    const placeholderElements = document.querySelectorAll('[data-translate-placeholder]');
    placeholderElements.forEach(element => {
        const key = element.dataset.translatePlaceholder;
        if (translations[currentLanguage] && translations[currentLanguage][key]) {
            element.placeholder = translations[currentLanguage][key];
        }
    });
}

function translateStatus(status) {
    if (translations[currentLanguage] && translations[currentLanguage][status]) {
        return translations[currentLanguage][status];
    }
    return status;
}

// API data loading
async function loadRepairData(ticketId) {
    let noInvoiceDataFound = false; // Flag to track if no invoice data is found
    try {
        document.getElementById('loading-overlay').style.display = 'flex';
        document.getElementById('invoice-container').style.display = 'none';

        // Initialize repairData with default structure
        repairData = {
            ticketId: ticketId,
            originalCustomerName: '',
            customerName: '',
            customerPhone: '',
            customerEmail: '',
            customerAddress: '',
            deviceBrand: '',
            deviceModel: '',
            deviceType: '',
            repairIssue: 'Repair needed',
            originalStoreName: '',
            originalOrgLabel: '',
            paymentStoreName: '',
            companyDisplayName: '',
            items: [] // Initialize items here
        };

        // Query for repair details from CS-UPDATE
        const repairDetailsQuery = {
            "size": 1, "collapse": { "field": "session_id.keyword" }, "sort": [{ "timestamp.keyword": "desc" }],
            "_source": { "excludes": ["__system_update_timestamp__"] },
            "query": { "bool": { "must": [
                { "terms": { "event_type.keyword": ["CS-UPDATE"] } },
                { "term": { "output.event_type.keyword": { "value": "CS_INVOICE" } } },
                { "term": { "output.data_formatted.order_id.keyword": { "value": ticketId } } }
            ]}}
        };

        const repairResponse = await fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(repairDetailsQuery)
        });

        console.log('Repair Details Query Response Status:', repairResponse.status);

        if (repairResponse.ok) {
            const repairDetailsData = await repairResponse.json();
            console.log('Repair Details Data:', repairDetailsData);
            if (repairDetailsData.hits && repairDetailsData.hits.hits.length > 0) {
                const formattedData = repairDetailsData.hits.hits[0]._source.output.data_formatted;
                repairData.items = formattedData.items || [];
                populateRepairItems(repairData.items);
                updateTotalsAndDates(formattedData, ticketId);
            } else {
                console.log('No repair details found for ticket ID:', ticketId);
                noInvoiceDataFound = true; // Set the flag
                showNoInvoiceInfo();
                return; // Stop further processing if no invoice data
            }
        } else {
            // Fallback on API error
            console.error('API error when loading repair details. Falling back.');
            noInvoiceDataFound = true; // Set the flag even on API error
            showNoInvoiceInfo();
            return;
        }


        // Query for customer and device info from CS-ORD
        const orderQueryBody = {
            "size": 1, "collapse": { "field": "session_id.keyword" }, "sort": [{ "timestamp.keyword": "desc" }],
            "_source": { "excludes": ["__system_update_timestamp__"] },
            "query": { "bool": {
                "must": [
                    { "terms": { "event_type.keyword": ["CS-ORD"] } },
                    { "term": { "output.data_formatted.order_id.keyword": { "value": ticketId } } }
                ],
                "must_not": [
                    { "terms": { "output.data_formatted.current_status.keyword": ["Closed", "Close", "close", "closed", "Đóng", "đóng", "Customer Replied", "Sent SMS"] } },
                    { "terms": { "session_name.keyword": ["Processing-Done"] } }
                ]
            }}
        };

        const orderResponse = await fetch(API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(orderQueryBody)
        });

        if (orderResponse.ok) {
            const orderData = await orderResponse.json();
            if (orderData.hits && orderData.hits.hits.length > 0) {
                const hit = orderData.hits.hits[0];
                const data = hit._source.output.data_formatted;
                const orgId = hit._source.metadata.org_id;
                console.log('org id: ', orgId)

                repairData = {
                    ticketId: ticketId,
                    originalCustomerName: data.customer_name || '',
                    customerName: data.customer_name || '',
                    customerPhone: data.customer_phone || '',
                    customerEmail: data.customer_email || '',
                    customerAddress: data.customer_address || '',
                    deviceBrand: data.device_brand || '',
                    deviceModel: data.device_model || '',
                    deviceType: data.device_type || '',
                    repairIssue: data.customer_reported_issue || 'Repair needed',
                    originalStoreName: data.store_name || '', // Store original store name from CS-ORD
                    originalOrgLabel: hit._source.metadata.org_lb || '', // Store original org label
                    paymentStoreName: '', // Will be populated by loadPaymentData
                    companyDisplayName: '', // Will be set by updateCompanyDisplayName
                    items: repairData.items || [] // Preserve existing items
                };

                if (orgId) {
                    
                    await loadPaymentData(orgId);
                }
                updateCompanyDisplayName(); // Call after payment data is loaded
                populateInvoiceData();
                showRepairStatus();
            } else {
                    // No order data found, but we might have invoice data, so don't throw a full error
                    console.warn('No order data found for this ticket ID');
            }
        } else {
            console.error('Error loading order data');
        }

    } catch (error) {
        console.error('Error loading repair data:', error);
        showErrorStatus();
    } finally {
        if (!noInvoiceDataFound) { // Only hide loading and show invoice if data was found
            hideLoading();
        }
    }
}

async function loadPaymentData(orgId) {
    console.log('loadPaymentData with orgId:', orgId);
    const paymentQueryBody = {
        "size": 1,
        "collapse": {
            "field": "session_id.keyword"
        },
        "sort": [{
            "__system_update_timestamp__": "desc"
        }],
        "query": {
            "bool": {
                "must": [{
                    "terms": {
                        "session_id.keyword": ["CS-PAYMENT"]
                    }
                }, {
                    "term": {
                        "event_type.keyword": {
                            "value": "CS-SETTINGS"
                        }
                    }
                }, {
                    "bool": {
                        "should": [{
                            "terms": {
                                "metadata.org_id.keyword": [orgId]
                            }
                        }]
                    }
                }]
            }
        }
    };

    try {
        const response = await fetch(API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(paymentQueryBody)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        console.log('Payment data response:', data);
        if (data.hits && data.hits.hits && data.hits.hits.length > 0) {
            const paymentData = data.hits.hits[0]._source.output.data;
            console.log('Payment data found:', paymentData);
            populatePaymentData(paymentData);
        } else {
            console.log('No payment data found for orgId:', orgId);
        }


    } catch (error) {
        console.error('Error loading payment data:', error);
    }
}



function populatePaymentData(paymentData) {
    if (!paymentData) return;

    // Populate Payment Method
    const paymentMethodEl = document.getElementById('payment-method');
    if (paymentMethodEl && paymentData.payment_method) {
        paymentMethodEl.textContent = paymentData.payment_method_html || paymentData.payment_method;
    }

    // Populate QR Code if payment_url exists
    const paymentQrContainer = document.getElementById('payment-qr-container');
    const paymentQrCode = document.getElementById('payment-qr-code');
    if (paymentData.payment_url) {
        paymentQrCode.src = paymentData.payment_url;
        paymentQrContainer.style.display = 'block';
    } else {
        paymentQrContainer.style.display = 'none';
    }

    // Populate Contact & Support Info
    const phoneEl = document.querySelector('[data-translate="phone"]').nextElementSibling;
    const emailEl = document.querySelector('[data-translate="email"]').nextElementSibling;
    const addressEl = document.querySelector('[data-translate="address"]').nextElementSibling;

    if (phoneEl && paymentData.store_phone_number) {
        phoneEl.textContent = paymentData.store_phone_number;
    }
    if (emailEl && paymentData.store_email) {
        emailEl.textContent = paymentData.store_email;
    }
    if (addressEl && paymentData.store_address) {
        addressEl.textContent = paymentData.store_address;
    }

    if (paymentData.store_name) {
        repairData.companyDisplayName = paymentData.store_name;
    }
    // Update the company name element on the page immediately after payment data is loaded
    const companyNameEl = document.getElementById('company-name');
    if (companyNameEl) {
        companyNameEl.textContent = repairData.companyDisplayName;
    }
}

function updateCompanyDisplayName() {
    if (!repairData) return;

    let companyName = translations[currentLanguage].companyName; // Default to translated company name

    if (repairData.paymentStoreName) {
        companyName = repairData.paymentStoreName;
    } else if (repairData.originalStoreName) {
        companyName = repairData.originalStoreName;
    } else if (repairData.originalOrgLabel) {
        companyName = repairData.originalOrgLabel;
    }

    repairData.companyDisplayName = companyName;

    // Update the company name element on the page
    const companyNameEl = document.getElementById('company-name');
    if (companyNameEl) {
        companyNameEl.textContent = repairData.companyDisplayName;
    }

    // Update company name in thank you message
    const thankYouCompanyNameEl = document.getElementById('thank-you-company-name');
    if (thankYouCompanyNameEl && repairData && repairData.companyDisplayName) {
        const translatedText = translations[currentLanguage].thankYou.replace('{companyName}', repairData.companyDisplayName);
        thankYouCompanyNameEl.textContent = translatedText;
    }
}

function populateInvoiceData() {
    console.log('Calling populateInvoiceData()');
    if (!repairData) return;

    // Update customer information
    document.getElementById('customer-name').textContent = maskName(repairData.customerName);
    document.getElementById('customer-email').textContent = maskEmail(repairData.customerEmail);
    document.getElementById('customer-phone').textContent = maskPhone(repairData.customerPhone);
    document.getElementById('customer-address').textContent = repairData.customerAddress||"";

    // Update device information
    document.getElementById('device-type').textContent = repairData.deviceType;
    document.getElementById('device-brand').textContent = repairData.deviceBrand;
    document.getElementById('device-model').textContent = repairData.deviceModel;
    document.getElementById('device-serial').textContent = repairData.deviceSerial;

    // Update ticket ID
    document.getElementById('invoice-number').textContent = `#INV-${repairData.ticketId}`;
    document.getElementById('ticket-id').textContent = repairData.ticketId;

    // Show repair issue if available
    if (repairData.repairIssue && repairData.repairIssue !== 'Repair needed') {
        document.getElementById('repair-issue-text').textContent = repairData.repairIssue;
    }
}

function showRepairStatus() {
    // No longer needed with simplified layout
}

function showErrorStatus() {
    // document.getElementById('loading-status').style.display = 'none';
    // document.getElementById('error-status').style.display = 'flex';
    // document.getElementById('repair-status').style.display = 'none';
    console.error("An error occurred while loading repair data.");
    hideLoading(); // Ensure loading overlay is hidden
}

function hideLoading() {
    document.getElementById('loading-overlay').style.display = 'none';
    document.getElementById('invoice-container').style.display = 'block';
}

function showNoInvoiceInfo() {
    console.log('Calling showNoInvoiceInfo()');
    document.getElementById('loading-overlay').style.display = 'flex';
    document.getElementById('loading-overlay').innerHTML = `
        <div class="text-center px-4">
            <i class="fas fa-exclamation-circle text-yellow-500 text-4xl mb-4"></i>
            <p class="text-gray-600 font-medium text-lg" data-translate="noInvoiceInfo"></p>
            <p class="text-gray-500 text-sm">Please check the ticket ID or try again later.</p>
        </div>
    `;
    translatePage(); // Translate the new content
}

// Utility functions
function maskName(name) {
    if (!name) return 'N/A';
    const parts = name.split(' ');
    return parts.map((part, idx) => idx === parts.length - 1 ? part[0] + '...' : part).join(' ');
}

function maskPhone(phone) {
    if (!phone || phone.length < 4) return 'N/A';
    return phone.slice(0, 4) + '***' + phone.slice(-2);
}

function maskEmail(email) {
    if (!email) return 'N/A';
    const [user, domain] = email.split('@');
    const visible = user.slice(0, 3);
    return `${visible}****@${domain}`;
}

function formatDateTime(timestamp) {
    const date = new Date(timestamp.replace(' ', 'T'));
    return date.toLocaleString(currentLanguage === 'vi' ? 'vi-VN' : 'en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
    });
}

function updateTotalsAndDates(data, ticketId) {
    const subtotal = parseFloat(data.subtotal || 0);
    const discount = parseFloat(data.discount || 0);
    const tax = parseFloat(data.tax || 0);
    const totalAmount = parseFloat(data.total_amount || 0);

    document.getElementById('subtotal').textContent = `${subtotal.toFixed(2)}`;
    document.getElementById('discount').textContent = `-${discount.toFixed(2)}`;
    document.getElementById('tax').textContent = `${tax.toFixed(2)}`;
    document.getElementById('total-amount').textContent = `${totalAmount.toFixed(2)}`;

    // Update payment instructions
    document.getElementById('payment-amount').textContent = `${totalAmount.toFixed(2)}`;
    document.getElementById('payment-reference').textContent = `#INV-${ticketId}`;

    if (data.invoice_date) {
        document.getElementById('invoice-date').textContent = data.invoice_date;
    }
    if (data.due_date) {
        document.getElementById('due-date').textContent = data.due_date;
    }
}

function populateRepairItems(itemsToPopulate) {
    console.log('Calling populateRepairItems()');
    const tbody = document.getElementById('repair-items');
    const mobileContainer = document.getElementById('repair-items-mobile');
    
    if (!tbody || !mobileContainer) return;

    // Use repairData.items if no specific items are provided
    const items = itemsToPopulate || (repairData ? repairData.items : []);

    tbody.innerHTML = '';
    mobileContainer.innerHTML = '';

    if (!items || items.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4" class="text-center py-4 text-gray-500">No repair items found.</td></tr>';
        return;
    }

    items.forEach(item => {
        const description = item.name || (currentLanguage === 'vi' ? item.descriptionVi : item.description) || 'N/A';
        const quantity = item.quantity || 1;
        const unitPrice = item.unit_price || item.unitPrice || 0;
        const total = item.amount || item.total || (quantity * unitPrice);
        
        // Use the 'category' field if it exists, otherwise fallback to the old logic
        const category = item.category || (description.toLowerCase().includes('labor') || description.toLowerCase().includes('công') ? 'labor' : 'parts');
        const typeLabel = translations[currentLanguage][category] || category;
        const typeColorClass = category === 'labor' ? 'bg-soft-purple text-purple-700' : 'bg-soft-blue text-indigo-700';

        // Desktop table row
        const row = document.createElement('tr');
        row.className = 'table-row border-b border-gray-100';
        row.innerHTML = `
            <td class="py-4 px-4">
                <div class="flex items-center space-x-3">
                    <span class="px-3 py-1 ${typeColorClass} text-xs rounded-full font-bold uppercase tracking-wide">${typeLabel}</span>
                    <span class="font-medium text-gray-800">${description}</span>
                </div>
            </td>
            <td class="text-center py-4 px-4 font-bold text-gray-800">${quantity}</td>
            <td class="text-right py-4 px-4 font-bold text-gray-800">${unitPrice.toFixed(2)}</td>
            <td class="text-right py-4 px-4 font-bold text-indigo-600">${total.toFixed(2)}</td>
        `;
        tbody.appendChild(row);

        // Mobile card
        const card = document.createElement('div');
        card.className = 'mobile-card-item';
        card.innerHTML = `
            <div class="mobile-card-row">
                <span class="mobile-card-label" data-translate="description">Description</span>
                <div class="flex items-center space-x-2">
                    <span class="px-2 py-1 ${typeColorClass} text-xs rounded-full font-bold">${typeLabel}</span>
                </div>
            </div>
            <div class="mb-2">
                <span class="mobile-card-value text-sm">${description}</span>
            </div>
            <div class="mobile-card-row">
                <span class="mobile-card-label" data-translate="qty">Qty</span>
                <span class="mobile-card-value">${quantity}</span>
            </div>
            <div class="mobile-card-row">
                <span class="mobile-card-label" data-translate="unitPrice">Unit Price</span>
                <span class="mobile-card-value">${unitPrice.toFixed(2)}</span>
            </div>
            <div class="mobile-card-row">
                <span class="mobile-card-label" data-translate="total">Total</span>
                <span class="mobile-card-value text-indigo-600 font-bold">${total.toFixed(2)}</span>
            </div>
        `;
        mobileContainer.appendChild(card);
    });
}

function initializePaymentForm() {
    const transferAmountInput = document.getElementById('transfer-amount');
    const uploadZone = document.getElementById('receipt-upload-zone');
    const confirmBtn = document.getElementById('confirm-payment-btn');

    // Set the placeholder for transfer amount based on the total amount due
    const totalAmountDue = document.getElementById('total-amount').textContent;
    transferAmountInput.placeholder = totalAmountDue;

    // Add click listener to the upload zone to trigger our new function
    if (uploadZone) {
        uploadZone.addEventListener('click', function() {
            initiateFileUpload();
        });
    }

    // Add click listener to the confirm button
    if (confirmBtn) {
        confirmBtn.addEventListener('click', function(e) {
            e.preventDefault(); // Prevent default button behavior
            confirmPayment();
        });
    }
}

// Initialize on page load
setTimeout(() => {
    // The loading is now hidden inside the loadRepairData function
}, 2000); // Fallback timeout



// --- AppFile Integration for Native File Upload ---

// This function is called when the user clicks the upload area.
function initiateFileUpload() {
    // Check if the AppFile bridge is available.
    if (typeof AppFile !== 'undefined' && AppFile.pickFile) {
        updateUploadStatus("Opening file picker...", "info");
        // Launch the native file picker. Allow images and PDFs.
        AppFile.pickFile('image/*', "filePickerCallback");
    } else {
        const msg = "Error: The 'AppFile' interface is not available. This page must be loaded within the app's WebView.";
        console.error(msg);
        updateUploadStatus(msg, "error");
        // As a fallback, we can trigger the original file input for web debugging.
        document.getElementById('file-upload').click();
    }
}

// Callback function to handle the result of the file picker.
function filePickerCallback(result) {
    if (result.error) {
        console.error("File picker error:", result.error);
        updateUploadStatus(`File selection failed: ${result.error}`, "error");
    } else {
        console.log("File selected:", result);
        updateUploadStatus(`File selected: ${result.name}. Preparing to upload...`, "info");

        const fileUri = result.uri;
        const apiEndpoint = 'https://storage.rta.vn/s3/upload';
        const project_code = configUser.projectCode;
        const filename = result.name;

        fetch(fileUri)
            .then(res => res.blob())
            .then(blob => {
                const formdata = new FormData();
                formdata.append(filename + "_FileMeta", JSON.stringify({ "project_code": project_code, "resource_type": "payment.receipt" }));
                formdata.append(filename + "_ExtraArgs", JSON.stringify({ "ACL": "public-read-write" }));
                formdata.append(filename, blob, filename);

                const requestOptions = {
                    method: "POST",
                    body: formdata,
                    redirect: "follow"
                };

                fetch(apiEndpoint, requestOptions)
                    .then(response => response.text())
                    .then(result => uploadCallback(result))
                    .catch(error => {
                        console.error("Error uploading file:", error);
                        updateUploadStatus(`Error uploading file: ${error.message}`, "error");
                    });
            });
    }
}

// Callback function to handle the result of the file upload process.
function uploadCallback(result) {
    if (result.error) {
        console.error("Upload error:", result.error);
        updateUploadStatus(`Upload failed: ${result.error}`, "error");
    } else if (result.progress !== undefined) {
        console.log("Upload progress:", result.progress + "%");
        updateUploadStatus(`Upload progress: ${result.progress}%`, "progress");
    } else {
        console.log("Upload success, server response:", result);
        try {
            const response = JSON.parse(result);
            // The public URL of the uploaded file.
            const publicUrl = response.files[0].public_url;

            // Store the URL in a hidden input for form submission
            const hiddenInput = document.getElementById('receipt-url');
            hiddenInput.value = publicUrl;

            // Update the UI to show the successful upload
            updateUploadStatus(`Upload complete! <a href="${publicUrl}" target="_blank" class="text-white underline">View Receipt</a>`, "success");

        } catch (e) {
            console.error("Could not parse server response:", e);
            updateUploadStatus("Upload successful, but the server response was unexpected.", "error");
            console.log("Raw response:", result);
        }
    }
}

// Helper function to update the UI in the upload area.
function updateUploadStatus(message, type) {
    const uploadZone = document.getElementById('receipt-upload-zone');
    const statusDiv = document.getElementById('upload-status-message');

    // Clear existing state
    uploadZone.classList.remove('border-indigo-300', 'border-green-500', 'border-red-500');
    statusDiv.innerHTML = '';

    switch (type) {
        case 'success':
            uploadZone.classList.add('border-green-500');
            statusDiv.innerHTML = `<i class="fas fa-check-circle text-green-500 mr-2"></i> ${message}`;
            break;
        case 'error':
            uploadZone.classList.add('border-red-500');
            statusDiv.innerHTML = `<i class="fas fa-exclamation-circle text-red-500 mr-2"></i> ${message}`;
            break;
        case 'progress':
             uploadZone.classList.add('border-indigo-300');
             statusDiv.innerHTML = `<div class="animate-spin rounded-full h-5 w-5 border-2 border-indigo-200 border-t-indigo-500 mr-2"></div> ${message}`;
             break;
        default: // 'info'
            uploadZone.classList.add('border-indigo-300');
            statusDiv.innerHTML = `<i class="fas fa-info-circle text-indigo-500 mr-2"></i> ${message}`;
            break;
    }
}

async function confirmPayment() {
    const confirmBtn = document.getElementById('confirm-payment-btn');
    const transferAmount = document.getElementById('transfer-amount').value;
    const transferDate = document.getElementById('transfer-date').value;
    const errorMessageDiv = document.getElementById('payment-error-message');

    // Clear previous error messages
    errorMessageDiv.textContent = '';
    errorMessageDiv.style.display = 'none';

    if (!transferAmount || !transferDate) {
        errorMessageDiv.textContent = 'Please fill in both "Amount Transferred" and "Transfer Date & Time" fields.';
        errorMessageDiv.style.display = 'block';
        confirmBtn.disabled = false;
        confirmBtn.innerHTML = '<i class="fas fa-check-circle"></i> <span data-translate="confirmPaymentBtn">Confirm Payment Completed</span>';
        return;
    }

    confirmBtn.disabled = true;
    confirmBtn.innerHTML = '<div class="animate-spin rounded-full h-5 w-5 border-2 border-white border-t-transparent mr-2"></div> <span data-translate="confirmingPayment">Confirming...</span>';

    const data = {
        ticket_id: repairData.ticketId,
        amount_transferred: document.getElementById('transfer-amount').value,
        transfer_datetime: document.getElementById('transfer-date').value,
        transaction_ref: document.getElementById('transfer-ref').value,
        receipt_url: document.getElementById('receipt-url').value,
        notes: document.getElementById('notes').value,
        customer_name: repairData.originalCustomerName,
        customer_phone: repairData.customerPhone,
        customer_email: repairData.customerEmail,
        company_name: repairData.companyDisplayName,
        total_amount_due: document.getElementById('total-amount').textContent,
        configUser: configUser // Add configUser to the data object
    };

    try {
        const response = await fetch('https://workflow.realtimex.co/api/v1/executions/webhook/flowai/realtimecs_confirm_payment/input', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        });

        if (response.ok) {
            document.getElementById('payment-form').style.display = 'none';
            document.getElementById('payment-success').style.display = 'block';
        } else {
            const errorData = await response.json();
            console.error('Payment confirmation failed:', errorData);
            alert('Payment confirmation failed. Please try again.');
            confirmBtn.disabled = false;
            confirmBtn.innerHTML = '<i class="fas fa-check-circle"></i> <span data-translate="confirmPaymentBtn">Confirm Payment Completed</span>';
        }
    } catch (error) {
        console.error('Error confirming payment:', error);
        alert('An error occurred. Please try again.');
        confirmBtn.disabled = false;
        confirmBtn.innerHTML = '<i class="fas fa-check-circle"></i> <span data-translate="confirmPaymentBtn">Confirm Payment Completed</span>';
    }
}
